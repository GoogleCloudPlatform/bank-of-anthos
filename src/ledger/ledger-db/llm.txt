# Ledger Database Service - LLM Documentation

## Overview
The `ledger-db` service is a PostgreSQL database that acts as an append-only ledger for all transaction data in the Bank of Anthos application. It serves as the source of truth for all financial transactions.

## Database Connection
- **Service Name**: `ledger-db`
- **Port**: `5432`
- **Database**: `postgresdb`
- **Username**: `admin`
- **Password**: `password`
- **Connection URI**: `postgresql://admin:password@ledger-db:5432/postgresdb`

## Environment Variables
- `SPRING_DATASOURCE_URL`: Full database connection URI
- `POSTGRES_DB`: Database name (postgresdb)
- `POSTGRES_USER`: Database username (admin)
- `POSTGRES_PASSWORD`: Database password (password)

## Database Schema

### Table: `transactions`
Primary table storing all financial transactions (append-only).

#### Columns:
- `transaction_id` (BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY): Auto-incrementing unique identifier
- `from_acct` (CHAR(10) NOT NULL): Source account number
- `to_acct` (CHAR(10) NOT NULL): Destination account number
- `from_route` (CHAR(9) NOT NULL): Source routing number
- `to_route` (CHAR(9) NOT NULL): Destination routing number
- `amount` (INT NOT NULL): Transaction amount in cents
- `timestamp` (TIMESTAMP NOT NULL): Transaction timestamp

#### Indexes:
- `transactions_from_acct_from_route_timestamp_idx`: Index on (from_acct, from_route, timestamp)
- `transactions_to_acct_to_route_timestamp_idx`: Index on (to_acct, to_route, timestamp)

#### Constraints:
- **Append-only**: Updates and deletes are prevented by database rules
- No foreign key constraints (external account references allowed)

## Common SQL Queries

### Add New Transaction
```sql
INSERT INTO transactions (from_acct, to_acct, from_route, to_route, amount, timestamp) 
VALUES (?, ?, ?, ?, ?, ?);
```

### Get Transactions for Account (Outgoing)
```sql
SELECT transaction_id, from_acct, to_acct, from_route, to_route, amount, timestamp 
FROM transactions 
WHERE from_acct = ? AND from_route = ? 
ORDER BY timestamp DESC;
```

### Get Transactions for Account (Incoming)
```sql
SELECT transaction_id, from_acct, to_acct, from_route, to_route, amount, timestamp 
FROM transactions 
WHERE to_acct = ? AND to_route = ? 
ORDER BY timestamp DESC;
```

### Get All Transactions for Account
```sql
SELECT transaction_id, from_acct, to_acct, from_route, to_route, amount, timestamp,
       CASE WHEN from_acct = ? AND from_route = ? THEN 'OUTGOING' ELSE 'INCOMING' END as direction
FROM transactions 
WHERE (from_acct = ? AND from_route = ?) OR (to_acct = ? AND to_route = ?)
ORDER BY timestamp DESC;
```

### Get Transaction by ID
```sql
SELECT transaction_id, from_acct, to_acct, from_route, to_route, amount, timestamp 
FROM transactions 
WHERE transaction_id = ?;
```

### Get Transaction History with Pagination
```sql
SELECT transaction_id, from_acct, to_acct, from_route, to_route, amount, timestamp 
FROM transactions 
WHERE (from_acct = ? AND from_route = ?) OR (to_acct = ? AND to_route = ?)
ORDER BY timestamp DESC 
LIMIT ? OFFSET ?;
```

### Get Transaction Statistics
```sql
SELECT 
    COUNT(*) as total_transactions,
    SUM(CASE WHEN from_acct = ? AND from_route = ? THEN amount ELSE 0 END) as total_outgoing,
    SUM(CASE WHEN to_acct = ? AND to_route = ? THEN amount ELSE 0 END) as total_incoming,
    SUM(CASE WHEN to_acct = ? AND to_route = ? THEN amount ELSE -amount END) as net_balance
FROM transactions 
WHERE (from_acct = ? AND from_route = ?) OR (to_acct = ? AND to_route = ?);
```

### Get Recent Transactions
```sql
SELECT transaction_id, from_acct, to_acct, from_route, to_route, amount, timestamp 
FROM transactions 
WHERE timestamp >= ? 
ORDER BY timestamp DESC;
```

## Python Integration Examples

### Using SQLAlchemy
```python
from sqlalchemy import create_engine, Column, BigInteger, String, Integer, DateTime
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from datetime import datetime
import os

# Database connection
DATABASE_URI = os.environ.get('SPRING_DATASOURCE_URL', 'postgresql://admin:password@ledger-db:5432/postgresdb')
engine = create_engine(DATABASE_URI)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

class Transaction(Base):
    __tablename__ = "transactions"
    
    transaction_id = Column(BigInteger, primary_key=True)
    from_acct = Column(String(10), nullable=False)
    to_acct = Column(String(10), nullable=False)
    from_route = Column(String(9), nullable=False)
    to_route = Column(String(9), nullable=False)
    amount = Column(Integer, nullable=False)  # Amount in cents
    timestamp = Column(DateTime, nullable=False)

# Usage
def add_transaction(from_acct, to_acct, from_route, to_route, amount_cents):
    session = SessionLocal()
    try:
        transaction = Transaction(
            from_acct=from_acct,
            to_acct=to_acct,
            from_route=from_route,
            to_route=to_route,
            amount=amount_cents,
            timestamp=datetime.utcnow()
        )
        session.add(transaction)
        session.commit()
        return transaction.transaction_id
    finally:
        session.close()

def get_account_transactions(account_num, routing_num, limit=50, offset=0):
    session = SessionLocal()
    try:
        transactions = session.query(Transaction).filter(
            (Transaction.from_acct == account_num) & (Transaction.from_route == routing_num) |
            (Transaction.to_acct == account_num) & (Transaction.to_route == routing_num)
        ).order_by(Transaction.timestamp.desc()).offset(offset).limit(limit).all()
        
        return [{
            'transaction_id': t.transaction_id,
            'from_acct': t.from_acct,
            'to_acct': t.to_acct,
            'from_route': t.from_route,
            'to_route': t.to_route,
            'amount': t.amount,
            'timestamp': t.timestamp,
            'direction': 'OUTGOING' if t.from_acct == account_num else 'INCOMING'
        } for t in transactions]
    finally:
        session.close()

def calculate_account_balance(account_num, routing_num):
    session = SessionLocal()
    try:
        # Get outgoing transactions
        outgoing = session.query(Transaction).filter(
            Transaction.from_acct == account_num,
            Transaction.from_route == routing_num
        ).all()
        
        # Get incoming transactions
        incoming = session.query(Transaction).filter(
            Transaction.to_acct == account_num,
            Transaction.to_route == routing_num
        ).all()
        
        total_outgoing = sum(t.amount for t in outgoing)
        total_incoming = sum(t.amount for t in incoming)
        net_balance = total_incoming - total_outgoing
        
        return {
            'total_outgoing': total_outgoing,
            'total_incoming': total_incoming,
            'net_balance': net_balance,
            'transaction_count': len(outgoing) + len(incoming)
        }
    finally:
        session.close()
```

### Using psycopg2
```python
import psycopg2
import os
from datetime import datetime

def add_transaction(from_acct, to_acct, from_route, to_route, amount_cents):
    conn = psycopg2.connect(os.environ.get('SPRING_DATASOURCE_URL'))
    cursor = conn.cursor()
    
    try:
        cursor.execute("""
            INSERT INTO transactions (from_acct, to_acct, from_route, to_route, amount, timestamp) 
            VALUES (%s, %s, %s, %s, %s, %s)
        """, (from_acct, to_acct, from_route, to_route, amount_cents, datetime.utcnow()))
        
        conn.commit()
        return cursor.lastrowid
    finally:
        cursor.close()
        conn.close()

def get_transaction_history(account_num, routing_num, limit=50, offset=0):
    conn = psycopg2.connect(os.environ.get('SPRING_DATASOURCE_URL'))
    cursor = conn.cursor()
    
    cursor.execute("""
        SELECT transaction_id, from_acct, to_acct, from_route, to_route, amount, timestamp,
               CASE WHEN from_acct = %s AND from_route = %s THEN 'OUTGOING' ELSE 'INCOMING' END as direction
        FROM transactions 
        WHERE (from_acct = %s AND from_route = %s) OR (to_acct = %s AND to_route = %s)
        ORDER BY timestamp DESC 
        LIMIT %s OFFSET %s
    """, (account_num, routing_num, account_num, routing_num, account_num, routing_num, limit, offset))
    
    results = cursor.fetchall()
    cursor.close()
    conn.close()
    
    return [{
        'transaction_id': row[0],
        'from_acct': row[1],
        'to_acct': row[2],
        'from_route': row[3],
        'to_route': row[4],
        'amount': row[5],
        'timestamp': row[6],
        'direction': row[7]
    } for row in results]

def get_transaction_by_id(transaction_id):
    conn = psycopg2.connect(os.environ.get('SPRING_DATASOURCE_URL'))
    cursor = conn.cursor()
    
    cursor.execute("""
        SELECT transaction_id, from_acct, to_acct, from_route, to_route, amount, timestamp 
        FROM transactions 
        WHERE transaction_id = %s
    """, (transaction_id,))
    
    result = cursor.fetchone()
    cursor.close()
    conn.close()
    
    if result:
        return {
            'transaction_id': result[0],
            'from_acct': result[1],
            'to_acct': result[2],
            'from_route': result[3],
            'to_route': result[4],
            'amount': result[5],
            'timestamp': result[6]
        }
    return None
```

## Transaction Processing Patterns

### Atomic Transaction Creation
```python
def process_transfer(from_acct, to_acct, from_route, to_route, amount_cents):
    """Process a transfer with atomic transaction creation"""
    conn = psycopg2.connect(os.environ.get('SPRING_DATASOURCE_URL'))
    cursor = conn.cursor()
    
    try:
        # Create the transaction record
        cursor.execute("""
            INSERT INTO transactions (from_acct, to_acct, from_route, to_route, amount, timestamp) 
            VALUES (%s, %s, %s, %s, %s, %s)
        """, (from_acct, to_acct, from_route, to_route, amount_cents, datetime.utcnow()))
        
        transaction_id = cursor.lastrowid
        conn.commit()
        
        return {
            'success': True,
            'transaction_id': transaction_id,
            'message': 'Transfer processed successfully'
        }
    except Exception as e:
        conn.rollback()
        return {
            'success': False,
            'error': str(e),
            'message': 'Transfer failed'
        }
    finally:
        cursor.close()
        conn.close()
```

### Batch Transaction Processing
```python
def process_batch_transactions(transactions):
    """Process multiple transactions in a single batch"""
    conn = psycopg2.connect(os.environ.get('SPRING_DATASOURCE_URL'))
    cursor = conn.cursor()
    
    try:
        transaction_ids = []
        for tx in transactions:
            cursor.execute("""
                INSERT INTO transactions (from_acct, to_acct, from_route, to_route, amount, timestamp) 
                VALUES (%s, %s, %s, %s, %s, %s)
            """, (tx['from_acct'], tx['to_acct'], tx['from_route'], tx['to_route'], tx['amount'], datetime.utcnow()))
            transaction_ids.append(cursor.lastrowid)
        
        conn.commit()
        return transaction_ids
    except Exception as e:
        conn.rollback()
        raise e
    finally:
        cursor.close()
        conn.close()
```

## Error Handling
- Always handle `psycopg2.OperationalError` for connection issues
- Handle `psycopg2.IntegrityError` for constraint violations
- Use transactions for multi-step operations
- Implement proper rollback on failures
- Log all transaction attempts for audit trails

## Performance Considerations
- Use indexes for account and routing number queries
- Consider connection pooling for high-traffic applications
- Use prepared statements for repeated queries
- Monitor query performance with EXPLAIN ANALYZE
- Consider partitioning for large transaction volumes
- Implement proper pagination for large result sets

## Security Notes
- No JWT authentication required (database service)
- Use parameterized queries to prevent SQL injection
- Validate input data before database operations
- Use environment variables for sensitive configuration
- Implement proper audit logging
- Consider data encryption for sensitive fields

## Audit and Compliance
- All transactions are immutable (append-only)
- Timestamps are automatically recorded
- No updates or deletes allowed
- Full transaction history maintained
- Suitable for financial compliance requirements

## Testing
- Test transaction creation and retrieval
- Test account balance calculations
- Test pagination and filtering
- Test error handling and rollbacks

## Deployment
- Kubernetes: `kubectl apply -f k8s/overlays/development/`
- Skaffold: `skaffold dev --module ledger-db`
- Docker: `docker build -t ledger-db .`
